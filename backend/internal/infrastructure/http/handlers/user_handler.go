package handlers

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"

	"github.com/kjanat/poo-tracker/backend/internal/domain/user"
	userDto "github.com/kjanat/poo-tracker/backend/internal/infrastructure/http/dto/user"
)

// UserHandler handles HTTP requests for user operations
type UserHandler struct {
	userService user.Service
}

// NewUserHandler creates a new user handler
func NewUserHandler(userService user.Service) *UserHandler {
	return &UserHandler{
		userService: userService,
	}
}

// Register handles user registration
// @Summary Register a new user
// @Description Create a new user account with email and password
// @Tags users
// @Accept json
// @Produce json
// @Param user body user.CreateUserRequest true "User registration data"
// @Success 201 {object} user.UserResponse
// @Failure 400 {object} shared.ErrorResponse
// @Failure 409 {object} shared.ErrorResponse
// @Router /api/v1/users/register [post]
func (h *UserHandler) Register(c *gin.Context) {
	var req userDto.CreateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request data",
			"details": err.Error(),
		})
		return
	}

	// Convert DTO to domain input
	input := &user.RegisterInput{
		Email:    req.Email,
		Username: req.Username,
		Password: req.Password,
		Name:     req.Name,
	}

	// Register user
	userEntity, err := h.userService.Register(c.Request.Context(), input)
	if err != nil {
		switch err {
		case user.ErrEmailAlreadyExists:
			c.JSON(http.StatusConflict, gin.H{
				"error": "Email already exists",
			})
		case user.ErrUsernameAlreadyExists:
			c.JSON(http.StatusConflict, gin.H{
				"error": "Username already exists",
			})
		case user.ErrInvalidEmail, user.ErrInvalidUsername, user.ErrWeakPassword:
			c.JSON(http.StatusBadRequest, gin.H{
				"error": err.Error(),
			})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to register user",
			})
		}
		return
	}

	// Convert to response DTO
	response := userDto.ToUserResponse(userEntity)
	c.JSON(http.StatusCreated, response)
}

// Login handles user authentication
// @Summary Authenticate user
// @Description Login with username/email and password
// @Tags users
// @Accept json
// @Produce json
// @Param credentials body user.LoginRequest true "Login credentials"
// @Success 200 {object} user.LoginResponse
// @Failure 400 {object} shared.ErrorResponse
// @Failure 401 {object} shared.ErrorResponse
// @Router /api/v1/users/login [post]
func (h *UserHandler) Login(c *gin.Context) {
	var req userDto.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request data",
			"details": err.Error(),
		})
		return
	}

	// Convert DTO to domain input
	input := &user.LoginInput{
		EmailOrUsername: req.Username, // DTO uses Username but domain supports both
		Password:        req.Password,
	}

	// Authenticate user
	result, err := h.userService.Login(c.Request.Context(), input)
	if err != nil {
		switch err {
		case user.ErrInvalidCredentials:
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": "Invalid credentials",
			})
		case user.ErrAccountDeactivated:
			c.JSON(http.StatusUnauthorized, gin.H{
				"error": "Account is deactivated",
			})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Login failed",
			})
		}
		return
	}

	// Convert to response DTO
	response := userDto.LoginResponse{
		User:  userDto.ToUserResponse(result.User),
		Token: result.Token, // Will be generated by JWT middleware
	}

	c.JSON(http.StatusOK, response)
}

// GetProfile handles getting current user profile
// @Summary Get user profile
// @Description Get current user's profile information
// @Tags users
// @Produce json
// @Security BearerAuth
// @Success 200 {object} user.UserResponse
// @Failure 401 {object} shared.ErrorResponse
// @Failure 404 {object} shared.ErrorResponse
// @Router /api/v1/users/profile [get]
func (h *UserHandler) GetProfile(c *gin.Context) {
	// Get user ID from JWT context (will be set by auth middleware)
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User not authenticated",
		})
		return
	}

	// Get user by ID
	userEntity, err := h.userService.GetByID(c.Request.Context(), userID.(string))
	if err != nil {
		switch err {
		case user.ErrUserNotFound:
			c.JSON(http.StatusNotFound, gin.H{
				"error": "User not found",
			})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to get user profile",
			})
		}
		return
	}

	// Convert to response DTO
	response := userDto.ToUserResponse(userEntity)
	c.JSON(http.StatusOK, response)
}

// UpdateProfile handles updating user profile
// @Summary Update user profile
// @Description Update current user's profile information
// @Tags users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param user body user.UpdateUserRequest true "Updated user data"
// @Success 200 {object} user.UserResponse
// @Failure 400 {object} shared.ErrorResponse
// @Failure 401 {object} shared.ErrorResponse
// @Failure 409 {object} shared.ErrorResponse
// @Router /api/v1/users/profile [put]
func (h *UserHandler) UpdateProfile(c *gin.Context) {
	// Get user ID from JWT context
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User not authenticated",
		})
		return
	}

	var req userDto.UpdateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request data",
			"details": err.Error(),
		})
		return
	}

	// Convert DTO to domain input
	input := req.ToUpdateUserInput()

	// Update user
	userEntity, err := h.userService.Update(c.Request.Context(), userID.(string), input)
	if err != nil {
		switch err {
		case user.ErrUserNotFound:
			c.JSON(http.StatusNotFound, gin.H{
				"error": "User not found",
			})
		case user.ErrEmailAlreadyExists:
			c.JSON(http.StatusConflict, gin.H{
				"error": "Email already exists",
			})
		case user.ErrUsernameAlreadyExists:
			c.JSON(http.StatusConflict, gin.H{
				"error": "Username already exists",
			})
		case user.ErrInvalidEmail, user.ErrInvalidUsername:
			c.JSON(http.StatusBadRequest, gin.H{
				"error": err.Error(),
			})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to update user profile",
			})
		}
		return
	}

	// Convert to response DTO
	response := userDto.ToUserResponse(userEntity)
	c.JSON(http.StatusOK, response)
}

// ChangePassword handles password changes
// @Summary Change user password
// @Description Change current user's password
// @Tags users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param password body user.ChangePasswordRequest true "Password change data"
// @Success 200 {object} shared.SuccessResponse
// @Failure 400 {object} shared.ErrorResponse
// @Failure 401 {object} shared.ErrorResponse
// @Router /api/v1/users/change-password [post]
func (h *UserHandler) ChangePassword(c *gin.Context) {
	// Get user ID from JWT context
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User not authenticated",
		})
		return
	}

	var req userDto.ChangePasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request data",
			"details": err.Error(),
		})
		return
	}

	// Convert DTO to domain input
	input := &user.ChangePasswordInput{
		CurrentPassword: req.CurrentPassword,
		NewPassword:     req.NewPassword,
	}

	// Change password
	err := h.userService.ChangePassword(c.Request.Context(), userID.(string), input)
	if err != nil {
		switch err {
		case user.ErrUserNotFound:
			c.JSON(http.StatusNotFound, gin.H{
				"error": "User not found",
			})
		case user.ErrInvalidCredentials:
			c.JSON(http.StatusBadRequest, gin.H{
				"error": "Current password is incorrect",
			})
		case user.ErrWeakPassword, user.ErrSamePassword:
			c.JSON(http.StatusBadRequest, gin.H{
				"error": err.Error(),
			})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to change password",
			})
		}
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Password changed successfully",
	})
}

// GetSettings handles getting user settings
// @Summary Get user settings
// @Description Get current user's settings and preferences
// @Tags users
// @Produce json
// @Security BearerAuth
// @Success 200 {object} user.UserSettingsResponse
// @Failure 401 {object} shared.ErrorResponse
// @Failure 404 {object} shared.ErrorResponse
// @Router /api/v1/users/settings [get]
func (h *UserHandler) GetSettings(c *gin.Context) {
	// Get user ID from JWT context
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User not authenticated",
		})
		return
	}

	// Get user settings
	settings, err := h.userService.GetSettings(c.Request.Context(), userID.(string))
	if err != nil {
		switch err {
		case user.ErrUserSettingsNotFound:
			c.JSON(http.StatusNotFound, gin.H{
				"error": "User settings not found",
			})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to get user settings",
			})
		}
		return
	}

	// Convert to response DTO
	response := userDto.ToUserSettingsResponse(settings)
	c.JSON(http.StatusOK, response)
}

// UpdateSettings handles updating user settings
// @Summary Update user settings
// @Description Update current user's settings and preferences
// @Tags users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param settings body user.UpdateSettingsRequest true "Updated settings"
// @Success 200 {object} user.UserSettingsResponse
// @Failure 400 {object} shared.ErrorResponse
// @Failure 401 {object} shared.ErrorResponse
// @Router /api/v1/users/settings [put]
func (h *UserHandler) UpdateSettings(c *gin.Context) {
	// Get user ID from JWT context
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User not authenticated",
		})
		return
	}

	var req userDto.UpdateSettingsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request data",
			"details": err.Error(),
		})
		return
	}

	// Convert DTO to domain input
	input := req.ToUpdateSettingsInput()

	// Update settings
	settings, err := h.userService.UpdateSettings(c.Request.Context(), userID.(string), input)
	if err != nil {
		switch err {
		case user.ErrUserNotFound:
			c.JSON(http.StatusNotFound, gin.H{
				"error": "User not found",
			})
		default:
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to update user settings",
			})
		}
		return
	}

	// Convert to response DTO
	response := userDto.ToUserSettingsResponse(settings)
	c.JSON(http.StatusOK, response)
}

// ListUsers handles getting list of users (admin only)
// @Summary List users
// @Description Get paginated list of users (admin only)
// @Tags users
// @Produce json
// @Security BearerAuth
// @Param limit query int false "Number of users to return" default(20)
// @Param offset query int false "Number of users to skip" default(0)
// @Success 200 {object} user.UserListResponse
// @Failure 401 {object} shared.ErrorResponse
// @Failure 403 {object} shared.ErrorResponse
// @Router /api/v1/users [get]
func (h *UserHandler) ListUsers(c *gin.Context) {
	// Parse query parameters
	limit := 20 // default
	if l := c.Query("limit"); l != "" {
		if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 {
			limit = parsed
		}
	}

	offset := 0 // default
	if o := c.Query("offset"); o != "" {
		if parsed, err := strconv.Atoi(o); err == nil && parsed >= 0 {
			offset = parsed
		}
	}

	// Get users list with pagination and total count
	users, totalCount, err := h.userService.ListWithCount(c.Request.Context(), limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to get users list",
		})
		return
	}

	// Convert to response DTOs
	userResponses := make([]userDto.UserResponse, len(users))
	for i, u := range users {
		userResponses[i] = userDto.ToUserResponse(u)
	}

	page := (offset / limit) + 1
	totalPages := int((totalCount + int64(limit) - 1) / int64(limit))

	response := userDto.UserListResponse{
		Users:      userResponses,
		TotalCount: totalCount,
		Page:       page,
		PageSize:   limit,
		TotalPages: totalPages,
	}

	c.JSON(http.StatusOK, response)
}
